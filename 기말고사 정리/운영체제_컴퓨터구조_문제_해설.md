## 문제 1
**프로세스의 상태 중 'Ready' 상태에 대한 설명으로 가장 적절한 것은?**  
ㄱ) CPU를 할당받아 명령어를 실행 중인 상태  
ㄴ) 프로세스가 생성되어 메모리에 적재된 상태  
ㄷ) CPU 할당을 기다리는 상태  
ㄹ) I/O 작업 완료를 기다리는 상태

**정답 및 해설:**
- ㄱ: 실행 중 상태(Running)이다.
- ㄴ: 준비 전 상태(New)이다.
- **ㄷ**: Ready 상태는 CPU 할당을 기다리는 상태이다.
- ㄹ: Blocked 상태이다.
## 문제 2
**프로세스 제어 블록(PCB)에 포함되지 않는 정보는?**  
ㄱ) 프로세스 ID  
ㄴ) 프로세스 상태  
ㄷ) CPU 레지스터 값  
ㄹ) 사용자 로그인 비밀번호

**정답:** ㄹ  
**해설:**

- PCB에는 프로세스 식별과 실행 관리를 위한 정보가 포함된다.
    
- 로그인 비밀번호는 운영체제가 관리하는 별도의 보안 정보이다.
    

---

## 문제 3

**프로세스가 'Blocked' 상태에서 'Ready' 상태로 전환되는 경우는?**  
ㄱ) 프로세스가 CPU를 할당받았을 때  
ㄴ) 프로세스가 I/O 작업을 요청했을 때  
ㄷ) 프로세스가 요청한 I/O 작업이 완료되었을 때  
ㄹ) 프로세스의 시간 할당량이 소진되었을 때

**정답:** ㄷ  
**해설:**

- I/O 작업 완료 시 Blocked → Ready 전환된다.
    
- ㄱ은 Ready → Running 전환,
    
- ㄴ은 Ready → Blocked 전환,
    
- ㄹ은 Running → Ready 전환이다.
    

---

## 문제 4

**프로세스 생성 시스템 호출인 fork()에 관한 설명으로 틀린 것은?**  
ㄱ) 부모 프로세스의 복제본인 자식 프로세스를 생성한다  
ㄴ) 부모 프로세스에서는 자식 프로세스의 PID를 반환한다  
ㄷ) 자식 프로세스에서는 0을 반환한다  
ㄹ) 자식 프로세스는 부모 프로세스와 완전히 다른 메모리 공간을 사용한다

**정답:** ㄹ  
**해설:**

- 자식 프로세스는 부모 프로세스의 메모리 공간을 복제하지만, 복제 후 독립적인 메모리를 가진다.
    
- 완전히 다른 메모리 공간은 아니며, 복사본이다.
    

---

## 문제 5

**라운드 로빈(Round Robin) 스케줄링 알고리즘에 대한 설명으로 옳은 것은?**  
ㄱ) 우선순위가 높은 프로세스에게 CPU를 먼저 할당한다  
ㄴ) 실행 시간이 짧은 프로세스에게 CPU를 먼저 할당한다  
ㄷ) 각 프로세스에게 동일한 시간 할당량(time quantum)을 부여한다  
ㄹ) I/O 작업이 많은 프로세스에게 우선권을 준다

**정답:** ㄷ  
**해설:**

- 라운드 로빈은 시간 할당량을 동일하게 나누어 CPU를 순환한다.
    
- 우선순위 기반 스케줄링과는 다르다.
    

---

## 문제 6

**세마포어(Semaphore)에 관한 설명 중 옳지 않은 것은?**  
ㄱ) 임계 구역 문제를 해결하기 위한 동기화 도구이다  
ㄴ) P(wait) 연산은 세마포어 값을 감소시킨다  
ㄷ) V(signal) 연산은 세마포어 값을 증가시킨다  
ㄹ) 이진 세마포어는 최대 값이 10이다

**정답:** ㄹ  
**해설:**

- 이진 세마포어는 0 또는 1만을 값으로 가진다.
    
- 최대 값이 10인 것은 카운팅 세마포어의 개념이다.
    

---

## 문제 7

**다음 중 교착 상태(Deadlock)의 필요 조건이 아닌 것은?**  
ㄱ) 상호 배제(Mutual Exclusion)  
ㄴ) 점유 및 대기(Hold and Wait)  
ㄷ) 선점 불가(No Preemption)  
ㄹ) 우선순위 역전(Priority Inversion)

**정답:** ㄹ  
**해설:**

- 교착 상태는 상호 배제, 점유 및 대기, 선점 불가, 원형 대기 조건이 필요하다.
    
- 우선순위 역전은 다른 문제이다.
    

---

## 문제 8

**프로세스 간 통신(IPC) 방법으로 가장 적합하지 않은 것은?**  
ㄱ) 파이프(Pipe)  
ㄴ) 메시지 큐(Message Queue)  
ㄷ) 공유 메모리(Shared Memory)  
ㄹ) 가상 메모리(Virtual Memory)

**정답:** ㄹ  
**해설:**

- 가상 메모리는 메모리 관리 기법이며, IPC 방법이 아니다.
    

---

## 문제 9

**CPU의 주요 구성 요소가 아닌 것은?**  
ㄱ) 산술 논리 장치(ALU)  
ㄴ) 제어 장치(Control Unit)  
ㄷ) 레지스터(Register)  
ㄹ) 페이지 테이블(Page Table)

**정답:** ㄹ  
**해설:**

- 페이지 테이블은 메모리 관리 장치에 속하며 CPU 내부 구성요소가 아니다.
    

---

## 문제 10

**CPU 레지스터 중 명령어 포인터(Instruction Pointer) 또는 프로그램 카운터(Program Counter)의 역할은?**  
ㄱ) 현재 실행 중인 명령어 주소를 저장  
ㄴ) 산술 연산의 결과값을 저장  
ㄷ) 메모리 접근 권한을 관리  
ㄹ) 인터럽트 처리 주소를 저장

**정답:** ㄱ  
**해설:**

- 프로그램 카운터는 다음에 실행할 명령어 주소를 저장한다.
## 문제 11  
다음 중 CISC(Complex Instruction Set Computer) 아키텍처의 특징이 아닌 것은?  
- ㄱ) 다양하고 복잡한 명령어 세트를 가진다  
- ㄴ) 명령어 길이가 가변적이다  
- ㄷ) 파이프라인 처리에 최적화되어 있다  
- ㄹ) 마이크로코드 제어 방식을 주로 사용한다  

**정답:** ㄷ  
**해설:**  
CISC 아키텍처는 복잡한 명령어를 많이 가지고 있고, 명령어 길이가 가변적이며 마이크로코드로 제어하지만, 파이프라인 처리에는 RISC가 더 최적화되어 있다.

---

## 문제 12  
CPU의 명령어 사이클(Instruction Cycle)에서 올바른 단계 순서는?  
- ㄱ) 인출(Fetch) → 실행(Execute) → 해독(Decode) → 저장(Store)  
- ㄴ) 인출(Fetch) → 해독(Decode) → 실행(Execute) → 저장(Store)  
- ㄷ) 해독(Decode) → 인출(Fetch) → 실행(Execute) → 저장(Store)  
- ㄹ) 저장(Store) → 인출(Fetch) → 해독(Decode) → 실행(Execute)  

**정답:** ㄴ  
**해설:**  
CPU 명령어 사이클은 명령어를 메모리에서 인출하고(Fetch), 해독(Decode) 후 실행(Execute), 마지막으로 결과를 저장(Store)하는 순서로 진행된다.

---

## 문제 13  
CPU 성능에 직접적인 영향을 미치지 않는 요소는?  
- ㄱ) 클럭 속도(Clock Speed)  
- ㄴ) 명령어 세트 아키텍처(ISA)  
- ㄷ) 캐시 크기(Cache Size)  
- ㄹ) 모니터 해상도(Monitor Resolution)  

**정답:** ㄹ  
**해설:**  
모니터 해상도는 CPU 성능에 영향을 미치지 않고, 클럭 속도, 명령어 집합, 캐시 크기 등이 직접 성능에 영향을 준다.

---

## 문제 14  
멀티코어 프로세서에 대한 설명으로 옳지 않은 것은?  
- ㄱ) 하나의 CPU 칩에 여러 개의 코어가 통합되어 있다  
- ㄴ) 병렬 처리를 통해 성능을 향상시킬 수 있다  
- ㄷ) 모든 소프트웨어가 자동으로 멀티코어의 이점을 활용할 수 있다  
- ㄹ) 전력 효율성이 향상될 수 있다  

**정답:** ㄷ  
**해설:**  
모든 소프트웨어가 멀티코어를 자동 활용하지 않으며, 병렬 처리를 위해서는 별도의 병렬 프로그래밍이 필요하다.

---

## 문제 15  
멀티스레딩(Multithreading)의 주요 이점이 아닌 것은?  
- ㄱ) 응답성 향상  
- ㄴ) 자원 공유 효율성  
- ㄷ) 메모리 사용량 감소  
- ㄹ) 멀티 프로세서 시스템에서의 병렬성 활용  

**정답:** ㄹ  
**해설:**  
멀티스레딩 자체는 멀티 프로세서 병렬성 활용과 직접 관련이 적으며, 이는 멀티코어 프로세서 환경에서의 특징이다.

---

## 문제 16  
파이프라인(Pipeline) 처리 방식에 대한 설명으로 올바른 것은?  
- ㄱ) 명령어 실행 속도를 높이기 위해 명령어를 여러 단계로 나누어 처리한다  
- ㄴ) 모든 명령어가 동일한 시간에 실행을 완료한다  
- ㄷ) 데이터 의존성이 있어도 성능 저하가 발생하지 않는다  
- ㄹ) 분기 예측이 필요 없다  

**정답:** ㄱ  
**해설:**  
파이프라인은 명령어를 여러 단계로 나누어 처리하여 실행 속도를 높인다. 데이터 의존성은 성능 저하를 일으키고, 분기 예측이 중요하다.

---

## 문제 17  
다음 중 속도가 가장 빠른 메모리는?  
- ㄱ) 하드 디스크(HDD)  
- ㄴ) 주 기억장치(RAM)  
- ㄷ) 캐시 메모리(Cache)  
- ㄹ) 레지스터(Register)  

**정답:** ㄹ  
**해설:**  
레지스터는 CPU 내부에 위치하며 가장 빠른 접근 속도를 가진다. 그 다음이 캐시, RAM, 하드 디스크 순이다.

---

## 문제 18  
캐시 메모리(Cache)에 관한 설명으로 옳지 않은 것은?  
- ㄱ) CPU와 주 메모리 사이의 속도 차이를 완화하기 위해 사용된다  
- ㄴ) 최근에 사용된 데이터나 명령어를 저장한다  
- ㄷ) 일반적으로 DRAM 기술을 사용한다  
- ㄹ) 캐시 히트(Cache Hit)는 요청된 데이터가 캐시에 있는 경우를 말한다  

**정답:** ㄷ  
**해설:**  
캐시 메모리는 일반적으로 SRAM을 사용하며, DRAM은 주 메모리에 사용된다.

---

## 문제 19  
가상 메모리(Virtual Memory)의 주요 목적으로 가장 적절한 것은?  
- ㄱ) CPU 처리 속도를 높이기 위함  
- ㄴ) 물리적 메모리보다 큰 주소 공간을 제공하기 위함  
- ㄷ) 하드 디스크의 속도를 향상시키기 위함  
- ㄹ) 전력 소비를 줄이기 위함  

**정답:** ㄴ  
**해설:**  
가상 메모리는 실제 물리 메모리보다 더 큰 주소 공간을 제공해 프로그램 실행 환경을 확장한다.

---

## 문제 20  
다음 중 비휘발성 메모리(Non-volatile Memory)가 아닌 것은?  
- ㄱ) ROM(Read-Only Memory)  
- ㄴ) DRAM(Dynamic Random Access Memory)  
- ㄷ) Flash Memory  
- ㄹ) EEPROM(Electrically Erasable Programmable ROM)  

**정답:** ㄴ  
**해설:**  
DRAM은 휘발성 메모리이며 전원이 꺼지면 데이터가 사라진다. 나머지는 비휘발성 메모리이다.

## 문제 21

페이징(Paging) 기법에 대한 설명으로 옳지 않은 것은?  
ㄱ) 물리적 메모리를 고정 크기의 프레임으로 나눈다  
ㄴ) 논리적 메모리를 고정 크기의 페이지로 나눈다  
ㄷ) 외부 단편화(External Fragmentation)가 발생한다  
ㄹ) 페이지 테이블을 통해 논리적 주소를 물리적 주소로 변환한다

**답:** ㄷ) 외부 단편화(External Fragmentation)가 발생한다

**해설:**  
페이징 기법은 내부 단편화(Internal Fragmentation)는 발생하지만, 고정 크기 페이지와 프레임 덕분에 외부 단편화는 발생하지 않는다.

---

## 문제 22

페이지 교체 알고리즘 중 LRU(Least Recently Used)에 대한 설명으로 가장 적절한 것은?  
ㄱ) 가장 오랫동안 메모리에 있었던 페이지를 교체한다  
ㄴ) 가장 최근에 사용된 페이지를 교체한다  
ㄷ) 가장 오랫동안 사용되지 않은 페이지를 교체한다  
ㄹ) 사용 빈도가 가장 낮은 페이지를 교체한다

**답:** ㄷ) 가장 오랫동안 사용되지 않은 페이지를 교체한다

**해설:**  
LRU 알고리즘은 가장 최근에 사용되지 않은 페이지를 우선적으로 교체하여 메모리 활용 효율을 높인다.

---

## 문제 23

TLB(Translation Lookaside Buffer)의 주요 기능은?  
ㄱ) 페이지 폴트 처리  
ㄴ) 페이지 테이블 접근 속도 향상  
ㄷ) 가상 메모리 크기 확장  
ㄹ) 디스크 접근 속도 향상

**답:** ㄴ) 페이지 테이블 접근 속도 향상

**해설:**  
TLB는 자주 참조되는 페이지 테이블 엔트리를 저장하여 주소 변환 속도를 높여 CPU의 메모리 접근 효율을 향상시킨다.

---

## 문제 24

스와핑(Swapping)에 대한 설명으로 옳은 것은?  
ㄱ) 프로세스 전체를 메모리에서 디스크로, 또는 디스크에서 메모리로 이동시키는 기법이다  
ㄴ) 레지스터 값을 교환하는 기법이다  
ㄷ) 캐시 메모리의 데이터를 교체하는 기법이다  
ㄹ) CPU 스케줄링 알고리즘의 일종이다

**답:** ㄱ) 프로세스 전체를 메모리에서 디스크로, 또는 디스크에서 메모리로 이동시키는 기법이다

**해설:**  
스와핑은 프로세스를 메모리와 디스크 사이에서 이동시켜 메모리 공간을 효율적으로 관리하는 기법이다.

---

## 문제 25

메모리 보호를 위한 기법이 아닌 것은?  
ㄱ) 기준-한계 레지스터(Base-Limit Register) 사용  
ㄴ) 페이지 테이블의 보호 비트(Protection Bit) 활용  
ㄷ) 세그먼트 테이블의 접근 권한 설정  
ㄹ) 라운드 로빈 스케줄링(Round Robin Scheduling)

**답:** ㄹ) 라운드 로빈 스케줄링(Round Robin Scheduling)

**해설:**  
라운드 로빈은 CPU 스케줄링 알고리즘으로 메모리 보호와는 관련이 없다.

---

## 문제 26

캐시 일관성(Cache Coherence) 문제가 발생하는 경우는?  
ㄱ) 단일 프로세서 시스템에서 멀티태스킹을 수행할 때  
ㄴ) 멀티프로세서 시스템에서 여러 프로세서가 공유 메모리에 접근할 때  
ㄷ) 가상 메모리 시스템에서 페이지 폴트가 발생할 때  
ㄹ) 프로세스가 종료되어 메모리를 해제할 때

**답:** ㄴ) 멀티프로세서 시스템에서 여러 프로세서가 공유 메모리에 접근할 때

**해설:**  
여러 프로세서가 같은 메모리 영역을 동시에 접근하면서 캐시가 불일치 상태가 되어 일관성 문제가 발생한다.

---

## 문제 27

메모리 성능 최적화와 관련이 없는 것은?  
ㄱ) 데이터 프리페칭(Prefetching)  
ㄴ) 메모리 인터리빙(Memory Interleaving)  
ㄷ) 캐시 최적화(Cache Optimization)  
ㄹ) 프로세스 우선순위 설정(Process Priority Setting)

**답:** ㄹ) 프로세스 우선순위 설정(Process Priority Setting)

**해설:**  
프로세스 우선순위는 CPU 스케줄링 관련이며, 메모리 성능 최적화에는 직접적인 관련이 없다.

---

## 문제 28

지역성 원리(Locality Principle)의 설명으로 옳지 않은 것은?  
ㄱ) 시간적 지역성(Temporal Locality)은 최근에 참조된 항목이 가까운 미래에 다시 참조될 가능성이 높다는 원리이다  
ㄴ) 공간적 지역성(Spatial Locality)은 참조된 항목 주변의 항목들이 곧 참조될 가능성이 높다는 원리이다  
ㄷ) 순차적 지역성(Sequential Locality)은 메모리가 순차적으로 접근될 때 성능이 저하된다는 원리이다  
ㄹ) 캐시 메모리 설계에 지역성 원리가 활용된다

**답:** ㄷ) 순차적 지역성(Sequential Locality)은 메모리가 순차적으로 접근될 때 성능이 저하된다는 원리이다

**해설:**  
순차적 지역성은 프로그램이 메모리를 순차적으로 접근하는 경향을 의미하며, 이는 성능 향상에 도움을 준다. 성능 저하는 아니다.

---

## 문제 29

다음 중 프로세스의 상태 변화에 대한 설명으로 올바르지 않은 것은?  
ㄱ) 실행(Running) 상태의 프로세스가 I/O 작업을 요청하면 대기(Waiting) 상태로 전이된다.  
ㄴ) 준비(Ready) 상태의 프로세스가 CPU를 할당받으면 실행(Running) 상태로 전이된다.  
ㄷ) 대기(Waiting) 상태의 프로세스는 인터럽트 발생 시 바로 실행(Running) 상태로 전이된다.  
ㄹ) 실행(Running) 상태의 프로세스가 시간 할당량을 모두 사용하면 준비(Ready) 상태로 전이된다.

**답:** ㄷ) 대기(Waiting) 상태의 프로세스는 인터럽트 발생 시 바로 실행(Running) 상태로 전이된다.

**해설:**  
대기 상태의 프로세스는 I/O가 완료되거나 이벤트가 발생하면 준비(Ready) 상태로 전이되고, CPU 할당 시 실행 상태로 전이된다.
## 문제 30  
프로세스 제어 블록(PCB)에 포함되지 않는 정보는?  
ㄱ) 프로세스 식별자(Process ID)  
ㄴ) 프로세스 상태(Process State)  
ㄷ) 하드 디스크의 전체 용량  
ㄹ) 프로그램 카운터 값  

**답:** ㄷ) 하드 디스크의 전체 용량  

> **해설:**  
> PCB에는 프로세스의 실행과 관련된 정보(프로세스 ID, 상태, 프로그램 카운터 등)가 저장된다. 하드 디스크 전체 용량은 프로세스와 무관한 시스템 자원 정보이다.

---

## 문제 31  
다음 중 CPU의 구성요소가 아닌 것은?  
ㄱ) 산술논리장치(ALU)  
ㄴ) 제어장치(Control Unit)  
ㄷ) 레지스터(Register)  
ㄹ) 페이지 테이블(Page Table)  

**답:** ㄹ) 페이지 테이블(Page Table)  

> **해설:**  
> 페이지 테이블은 메모리 관리의 데이터 구조이며, CPU의 하드웨어 구성 요소가 아니다. CPU는 ALU, 제어장치, 레지스터로 구성된다.

---

## 문제 32  
CPU의 명령어 사이클에서 일반적으로 가장 먼저 수행되는 단계는?  
ㄱ) 실행(Execute)  
ㄴ) 인출(Fetch)  
ㄷ) 저장(Store)  
ㄹ) 해석(Decode)  

**답:** ㄴ) 인출(Fetch)  

> **해설:**  
> 명령어 사이클은 보통 인출 → 해석 → 실행 → 저장 순서로 진행된다. 먼저 메모리에서 명령어를 인출한다.

---

## 문제 33  
다음 중 RISC(Reduced Instruction Set Computer) 아키텍처의 특징으로 올바르지 않은 것은?  
ㄱ) 간단하고 적은 수의 명령어 집합을 사용한다.  
ㄴ) 대부분의 명령어가 한 클럭 사이클 내에 실행된다.  
ㄷ) 복잡한 주소 지정 모드를 많이 제공한다.  
ㄹ) 레지스터를 많이 사용하여 메모리 접근을 최소화한다.  

**답:** ㄷ) 복잡한 주소 지정 모드를 많이 제공한다.  

> **해설:**  
> RISC는 간단한 명령어와 단순한 주소 지정 모드를 사용하여 명령어를 빠르게 실행한다. 복잡한 주소 지정 모드는 CISC의 특징이다.

---

## 문제 34  
다음 중 프로그램 카운터(PC)의 역할로 가장 적절한 것은?  
ㄱ) 산술 연산의 결과를 저장한다.  
ㄴ) 현재 실행 중인 명령어를 저장한다.  
ㄷ) 다음에 실행할 명령어의 주소를 저장한다.  
ㄹ) 메모리에서 읽어온 데이터를 저장한다.  

**답:** ㄷ) 다음에 실행할 명령어의 주소를 저장한다.  

> **해설:**  
> 프로그램 카운터는 다음에 실행할 명령어의 주소를 저장하여 CPU가 순차적으로 명령을 실행할 수 있게 한다.

---

## 문제 35  
CPU의 상태 레지스터(Status Register)에 저장되는 정보가 아닌 것은?  
ㄱ) 제로 플래그(Zero Flag)  
ㄴ) 캐리 플래그(Carry Flag)  
ㄷ) 인터럽트 활성화 비트  
ㄹ) 다음 명령어의 주소  

**답:** ㄹ) 다음 명령어의 주소  

> **해설:**  
> 상태 레지스터는 조건 플래그(제로, 캐리 등)와 제어 비트를 저장하지만, 다음 명령어 주소는 프로그램 카운터가 담당한다.

---

## 문제 36  
다음 중 명령어 파이프라이닝(Instruction Pipelining)의 주요 목적으로 가장 적절한 것은?  
ㄱ) CPU의 클럭 속도를 높이기 위함  
ㄴ) 명령어 실행의 병렬화를 통한 처리량(throughput) 향상  
ㄷ) 메모리 접근 속도를 높이기 위함  
ㄹ) 명령어의 크기를 줄이기 위함  

**답:** ㄴ) 명령어 실행의 병렬화를 통한 처리량(throughput) 향상  

> **해설:**  
> 파이프라이닝은 명령어 실행 단계를 겹쳐 수행하여 CPU 처리량을 증가시키는 기술이다.

---

## 문제 37  
다음 중 메모리의 특성에 관한 설명으로 옳지 않은 것은?  
ㄱ) RAM은 휘발성 메모리로, 전원이 꺼지면 저장된 정보가 사라진다.  
ㄴ) ROM은 비휘발성 메모리로, 전원이 꺼져도 저장된 정보가 유지된다.  
ㄷ) 캐시 메모리는 주 메모리보다 접근 속도가 느리다.  
ㄹ) 가상 메모리는 주 메모리의 용량 제한을 극복하기 위해 보조 기억장치의 일부를 사용한다.  

**답:** ㄷ) 캐시 메모리는 주 메모리보다 접근 속도가 느리다.  

> **해설:**  
> 캐시 메모리는 주 메모리보다 훨씬 빠른 속도로 동작하여 CPU와 주 메모리 간의 속도 차이를 줄여준다.

---

## 문제 38  
다음 기억장치 중 접근 속도가 가장 빠른 것은?  
ㄱ) 하드 디스크 드라이브(HDD)  
ㄴ) 주 메모리(RAM)  
ㄷ) L1 캐시  
ㄹ) 솔리드 스테이트 드라이브(SSD)  

**답:** ㄷ) L1 캐시  

> **해설:**  
> L1 캐시는 CPU 내부에 위치한 매우 빠른 캐시 메모리로, RAM이나 SSD, HDD보다 접근 속도가 훨씬 빠르다.

---

## 문제 39  
캐시 메모리에서 사용되는 지역성(Locality) 원리에 대한 설명으로 옳지 않은 것은?  
ㄱ) 시간적 지역성(Temporal Locality)은 최근에 참조된 메모리 위치가 가까운 미래에 다시 참조될 가능성이 높다는 원리이다.  
ㄴ) 공간적 지역성(Spatial Locality)은 특정 메모리 위치가 참조되면 그 주변 메모리 위치도 곧 참조될 가능성이 높다는 원리이다.  
ㄷ) 순차적 지역성은 프로그램이 메모리에 순차적으로 저장된 명령어를 순차적으로 실행하는 경향을 의미한다.  
ㄹ) 지역성 원리는 캐시 메모리의 크기를 늘리는 것보다 접근 속도를 높이는 것이 더 중요함을 시사한다.  

**답:** ㄹ) 지역성 원리는 캐시 메모리의 크기를 늘리는 것보다 접근 속도를 높이는 것이 더 중요함을 시사한다.  

> **해설:**  
> 지역성 원리는 메모리 참조 패턴에 관한 원리로, 캐시 크기 증가보다는 참조 패턴을 이용해 효율을 높이는 데 중점을 둔다. 접근 속도 향상과 직접적인 관련은 적다.

---

## 문제 40  
다음 중 페이지 폴트(Page Fault)가 발생하는 상황으로 가장 적절한 것은?  
ㄱ) CPU가 캐시 메모리에서 데이터를 찾지 못할 때  
ㄴ) 프로세스가 접근하려는 페이지가 물리적 메모리에 없을 때  
ㄷ) 메모리 주소 계산 과정에서 산술 오버플로우가 발생할 때  
ㄹ) 프로세스가 다른 프로세스의 메모리 영역에 접근하려 할 때  

**답:** ㄴ) 프로세스가 접근하려는 페이지가 물리적 메모리에 없을 때  

> **해설:**  
> 페이지 폴트는 가상 메모리 시스템에서 요청한 페이지가 주 메모리에 없을 때 발생하며, 운영체제가 해당 페이지를 보조 기억장치에서 로드한다.

---

## 문제 41  
페이지 교체 알고리즘 중 LRU(Least Recently Used)에 대한 설명으로 옳은 것은?  
ㄱ) 가장 오래 사용되지 않은 페이지를 교체한다.  
ㄴ) 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체한다.  
ㄷ) 가장 최근에 사용된 페이지를 교체한다.  
ㄹ) 무작위로 페이지를 선택하여 교체한다.  

**답:** ㄱ) 가장 오래 사용되지 않은 페이지를 교체한다.  

> **해설:**  
> LRU 알고리즘은 가장 오랫동안 참조되지 않은 페이지를 교체하여, 최근에 자주 사용된 페이지를 유지한다.

---

## 문제 42  
가상 메모리 시스템에서 TLB(Translation Lookaside Buffer)의 주요 목적은?  
ㄱ) 페이지 교체 알고리즘의 성능을 향상시킨다.  
ㄴ) 페이지 테이블 접근 시간을 줄여 주소 변환 속도를 높인다.  
ㄷ) 디스크 I/O 작업의 효율성을 향상시킨다.  
ㄹ) 프로세스 간 메모리 공유를 용이하게 한다.  

**답:** ㄴ) 페이지 테이블 접근 시간을 줄여 주소 변환 속도를 높인다.  

> **해설:**  
> TLB는 최근에 사용된 페이지 테이블 엔트리를 캐싱하여, 주소 변환 시 페이지 테이블 조회 시간을 줄인다.

---

## 문제 43  
다음 중 인터럽트 처리 과정에서 일반적으로 발생하지 않는 단계는?  
ㄱ) 현재 실행 중인 프로세스의 상태 저장  
ㄴ) 인터럽트 벡터 테이블을 통해 인터럽트 서비스 루틴(ISR) 주소 확인  
ㄷ) 인터럽트 서비스 루틴 실행  
ㄹ) 모든 실행 중인 프로세스를 강제 종료  

**답:** ㄹ) 모든 실행 중인 프로세스를 강제 종료  

> **해설:**  
> 인터럽트는 일시적으로 현재 프로세스를 중단하고 ISR을 수행하지만, 모든 프로세스를 종료하지는 않는다.

---

## 문제 44  
DMA(Direct Memory Access)의 주요 목적으로 가장 적절한 것은?  
ㄱ) CPU의 클럭 속도를 높이기 위함  
ㄴ) 입출력 작업 중 CPU 개입을 최소화하여 시스템 효율성을 높이기 위함  
ㄷ) 메모리 접근 속도를 높이기 위함  
ㄹ) 입출력 장치의 오류를 감지하기 위함  

**답:** ㄴ) 입출력 작업 중 CPU 개입을 최소화하여 시스템 효율성을 높이기 위함  

> **해설:**  
> DMA는 CPU를 거치지 않고 입출력 장치와 메모리가 직접 데이터를 주고받아 CPU 부하를 줄인다.

---

## 문제 45  
다음 중 폴링(Polling) 방식의 입출력에 대한 설명으로 옳지 않은 것은?  
ㄱ) CPU가 주기적으로 입출력 장치의 상태를 확인한다.  
ㄴ) 인터럽트 방식에 비해 CPU 사용 효율성이 높다.  
ㄷ) 간단한 구현이 가능하다.  
ㄹ) 실시간 응답이 중요한 일부 시스템에서 사용된다.  

**답:** ㄴ) 인터럽트 방식에 비해 CPU 사용 효율성이 높다.  

> **해설:**  
> 폴링은 CPU가 계속 상태를 확인하므로 CPU 자원을 많이 사용해 효율성이 낮다. 인터럽트 방식이 효율적이다.
