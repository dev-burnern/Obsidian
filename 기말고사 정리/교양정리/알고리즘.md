## 탐색
- 주어진 데이터에서 조건에 맞는 혹은 원하는 정보를 찾아내는 작업

## 순차 탐색
- **순서 없이 저장된 데이터**에서 원하는 정보를 탐색하는 방법
- 데이터를 **처음부터 끝까지 모두 탐색**해서 원하는 정보를 찾아냄
- **전체 탐색**임

## 이진 탐색
- **순서대로 저장된 데이터**에서 정보 찾음

이진탐색의 효율성
- **순차탐색은** 최대 **N**
- **이진탐색**은 최대**log2N**
- **시간복잡도**에서 유리함

## 정렬
순서 없이 저장된 데이터를 일정한 순서대로 열거
- **오름차순**: 값이 작은 것부터 큰 순
- **내림차순**: 값이 큰 것부터 작은 순

필요성 
- 원하는 정보를 **검색**하는데 드는 **시간 단축**
- **정보를 보다 가치 있게** 활용

| 정렬 알고리즘 | 시간 복잡도 (최선/평균/최악)               | 공간 복잡도   | 안정성 | 특징 및 장단점                                                                                                                                                                                                          |
| ------- | ------------------------------- | -------- | --- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 선택 정렬   | O(n²) / O(n²) / O(n²)           | O(1)     | 불안정 | 구현이 매우 쉽고, 교환 횟수가 적음. 하지만 효율이 낮아 대규모 데이터에는 부적합                                                                                                                                                                    |
| 버블 정렬   | O(n) / O(n²) / O(n²)            | O(1)     | 안정  | 구현이 가장 쉬움. 인접 요소를 반복적으로 비교 및 교환. 효율이 낮음[1](https://blog.naver.com/baeusa1/221519928113)[2](https://yabmoons.tistory.com/250)[5](https://blog.naver.com/gkenq/220715758590)[6](https://codingwell.tistory.com/186) |
| 버킷 정렬   | O(n+k) / O(n+k) / O(n²)         | O(n+k)   | 안정  | 데이터가 균등하게 분포되어 있을 때 매우 빠름. 추가 메모리 필요. 데이터 분포에 따라 성능 차이 큼[1](https://blog.naver.com/baeusa1/221519928113)                                                                                                          |
| 삽입 정렬   | O(n) / O(n²) / O(n²)            | O(1)     | 안정  | 거의 정렬된 데이터에 매우 효율적. 구현이 간단함. 데이터가 많거나 역순일 때 비효율적[1](https://blog.naver.com/baeusa1/221519928113)[2](https://yabmoons.tistory.com/250)[6](https://codingwell.tistory.com/186)                                      |
| 퀵 정렬    | O(n log n) / O(n log n) / O(n²) | O(log n) | 불안정 | 평균적으로 매우 빠름. 분할정복 방식. 피벗 선택에 따라 최악의 경우 O(n²) 발생                                                                                                                                                                   |